class Solution {

    public int minEatingSpeed(int[] piles, int h) {
        int start = 1, end = piles[0];
        for(int i=1; i < piles.length; i++){
            end = Math.max(end, piles[i]);
        }
        while(start < end){
            int mid = start + (end-start)/2;
            if(isValid(mid, piles, h)){
                end = mid;
            }else{
                start = mid+1;
            }
        }
        return end;
    }
    private boolean isValid(int mid, int[] piles, int h){
        int total_h = 0;
        for(int i=0; i < piles.length; i++){
            if(mid >= piles[i])
               total_h += 1;
            else
               total_h += (int)Math.ceil((double)piles[i]/mid);
        }
        return total_h <= h; 
    }
}


Complexity Analysis

Let n be the length of the input array piles and m be the maximum number of bananas in a single pile from piles.

Time complexity: O(n⋅logm)

The initial search space is from 1 to m, it takes logm comparisons to reduce the search space to 1.
For each eating speed middle, we traverse the array and calculate the overall time Koko spends, which takes O(n) for each traversal.
To sum up, the time complexity is O(n⋅logm).
Space complexity: O(1)

For each eating speed middle, we iterate over the array and calculate the total hours Koko spends, which costs constant space.
Therefore, the overall space complexity is O(1).
