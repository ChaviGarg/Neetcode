In this modified version of binary search algorithm, we are looking for this point. In the above example notice the Inflection Point .

All the elements to the left of inflection point > first element of the array.

All the elements to the right of inflection point < first element of the array.

Algorithm

Find the mid element of the array.

If mid element > first element of array this means that we need to look for the inflection point on the right of mid.

If mid element < first element of array this means that we need to look for the inflection point on the left of mid.


class Solution {
                
    public int findMin(int[] nums) {
        int start = 0, end = nums.length-1;
        while(start < end){
            int mid = start + (end - start)/2;
            if(mid+1 < nums.length && nums[mid] > nums[mid+1])
                return nums[mid+1];
            else if(mid > 0 && nums[mid] < nums[mid-1])
                return nums[mid];
            else if(nums[mid] > nums[start])
                start = mid+1;
            else 
                end = mid-1;
        }
        return nums[0];
    }
}

Complexity Analysis

Time Complexity : Same as Binary Search O(logN)
Space Complexity : O(1)
