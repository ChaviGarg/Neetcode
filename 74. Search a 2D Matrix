class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0, j = matrix[0].length-1;
        while(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length){
            if(matrix[i][j] < target){
                i++;
            }else if(matrix[i][j] > target){
                j--;
            }else{
                return true;
            }
        }
        return false;
    }
}

Each iteration either increases i or decreases j, so:
You can move down at most m times (number of rows),
You can move left at most n times (number of columns).
Thus, the loop runs at most m + n times.
âœ… Time Complexity = O(m + n)
(where m = number of rows, n = number of columns)

Optmized (binary search)  -> consider it as a 1-d sorted array

class Solution {
  
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length; 
        int start = 0, end = (m*n)-1;
        while(start <= end){
            int mid = start + (end - start)/2;
            int midVal = matrix[mid/n][mid%n];
            if(midVal == target)
                return true;
            else if(midVal > target){
                end = mid-1;
            }else{
                start = mid+1;
            }
        }
        return false;
    }
}

// Time complexity : O(log(m*n))

